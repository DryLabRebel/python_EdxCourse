IMB/Edx Python course notes
===========================

Course Notes for the IMB python short course

```{python}
print( "hello world" )
```

Again, looks like I should be pretty familiar with all this stuff. I need to start actually coding.

[//]: # ( OK, I think I see the problem now, when I start Rmd. python won't start --- WHY!? )
[//]: # ( Same thing happened when I tried to execute a .py program from the command line -- I need to fix this )

Before I finish this course:

- Get python working (maybe it needs to be running inside a conda environment?)
- Get python scripts executing from the command line

Module 1
--------

Python Basics: 

### types ###

Pretty straightforwards stuff.

integers, floats, strings and booleans.

You can make conversions between types - python is pretty clever - and can even convert strings to integers (assuming the string is an integer), like

```{python}
int('1')
```

Will convert '1', into the integer 1.

Floats to integers drops the decimal, and thus loses information.

You can't convert lettersa and symbols to ints (but what about ACII codes?)

Booleans are either true (1) or false (0).

### Expressions ###

Just basic operations.

Variable assignment

```{python}
my_variable = 1
my_variable:1 # will apparently 'denote' the variable, which I'm wondering how this is different from assignment??
```

More straightforward stuff.

### Strings ###

Each element in a string is indexed by integers, either positive or negative.

String operations are fairly intuitive.

    3 * x == xxx

You cannot 'add' a string, but you can add *to* a string.

`3 + x` -- returns an error

But `'3' + x` -- adds the number '3' to the string

Backslashes `\`, as usual are escape characters.

Slicing can be done using indexes.

```{python}
a = 'the cat in the hat '
a[::2] # Take every second character starting from one -- THIS IS A STRIDE VALUE
# 'tecti h a '
a[0:5:2] # Take from 0 to 5, and return every second character - this is slicing
# 'tec'

"345678".find('3') # Ah I see -- 'return index value of string '3'
```

Module 2
--------

### Lists and tuples ###

Tuples are ordered lists, defined by parentheses.

Tuples can be made of strings, integers, floats, etc. and any combination of these.

A tuple is always of type: tuple.

Tuples can be sliced and concatenated.

```{python}
tuple1 = (1,2,3,4)
tuple2 = ('cat','dog',5.3)

tuple1 + tuple2 = tuple3

tuple3 =  (1,2,3,4,'cat','dog',5.3)

tuple3[2:5]

# (3,4,'cat')

tuple4 = (5,3.2,9,"letter opener",tuple3)

tuple4[4][5][1]

# o

```

So tuples can be nested. Which is even more powerful than it sounds.

From what I can gather, this is the equivalent of creating a list in R.

We can index down to the atomic level, even within strings.

Lists are like tuples, but mutable.

```{python}

list1 = ["Michael Jackson", 10.1, 1982]

list1.extend(["pop", 10])

list1 = ["Michael Jackson", 10.1, 1982, "pop", 10]

list1.append(["pop", 10])

list1 = ["Michael Jackson", 10.1, 1982, "pop", 10, ["pop", 10]]

list1[3] = "soda"

list1 = ["Michael Jackson", 10.1, 1982, "soda", 10, ["pop", 10]]

del(list1[1])

list1 = ["Michael Jackson", 1982, "soda", 10, ["pop", 10]]

"hard rock".split()

# ["hard", "rock"]
# so \s is the default delimiter then?

"a,b,c,d".split(',')

# ["a","b","c","d"]

# I guess that answers my question

```

OK, interesting.

Aliasing.

```{python}
A=B

```

aliases A with B. When you change anything in list A, it changes in B too.

Cloning:

```{python}
B=A[:]
# Again, it is simply referencing all elements of A
```

This will create an independent clone of A: B. A change in A will not induce a change in A, because they are now independent.

A fellow student shared [this](https://stackabuse.com/lists-vs-tuples-in-python/) really interesting tutorial on lists vs tuples.

It's becoming increasingly evident that I should find other ways to practise coding, other than the labs here.

Python is obviously more complex than SQL, and the labs are auite simple.

### Data Structures ###

Sets area  type of collection

you can input types.

Sets are unordered

Only have unique elements (no duplicates!).

use curly brackets

```{python}

set1={'dog','cat','aardvark','mouse'}

```

You can convert lists to sets

```{python}
list8 = set(list1)
```

Can add to a set

```{python}
set1.add('tiger')
```

If we add an element that exists, nothign will happen.

Can check to see if an item is in a set:

```{python}
'cat' in set1
```

We can perform lots of mathematical operations in sets.

```{python}

set1={'dog','cat','aardvark','mouse'}

set2={'dog','mouse','elephant','sloth'}

```

For intersection we use `&`

This will find the common elements of each set.

```{python}

# intersection
set1 & set2

# {'dog','mouse'}

# union

set1.union(set2)

# check to find if a set is a subset of another

set1.issubset(set2)

# False

```

### Dictionaries ###

Dictionaries are like lists.

Except their indexes are not integers, but custom values, often characters or strings.

The syntax is as follows:

```{python}
dictionary1 = {"key":"value","key2":[1,2,3],"key3":"5",("key6"):5}
```

Nice to think of a dictionary as a two column table

key | variable

We can add to a dictionary

```{python}
dictionary1['key4']='(5,4)'

del(dictionary1['key4'])

'key' in dictionary1
# true

'key1' in dictionary1
# false

dictionary1.keys()

dictionary1.values()

```

Module 3
--------

Zooming along again. When did I start this? Was it Sunday or Saturday?

- lots of familiar content
- should really do some real coding
  - eh, finish the course first

1. conditions and branching
2. loops and functions
3. objects and classes

### Conditions and branching ###

Mostly just stuff on operators and conditionals.

If statements. syntax?

```{python}

if (age>18): # The brackets are not necessary!

  print("you can enter")

print("move on")

```


```{python}

age = 17

if (age>18): # The brackets are not necessary!

  print("you can enter")

print("move on")

```

```{python}

if (age>18): # The brackets are not necessary!

  print("you can enter")

else:

  print("go see Meatloaf")

print("move on")

```

```{python}

if (age>18): # The brackets are not necessary!

  print("you can enter")

elif(age==18):

  print("go see Pink Floyd")

else:

  print("go see Meatloaf")

print("move on")

```

Logic Operators

AND and OR booleans.

Pretty straightforward stuff.

```{python}

albumYear = 1970

if albumYear < 1980 and albumYear > 1969:
  print("This album was made in the 70's")

```

### Loops ###

`range()` generates number sequences based on its input

```{python}
range(3)
# [0,1,2]
range(10,15)
# [10,11,12,13,14]
```

for loops, exactly as they are in essentially any other language, at least the basic concept is the same.

```{python}
squares = ["red","yellow","green","purple","blue"]
for i in range(0,5):
  squares[i]="white"

# We can iterate directly on the list

for i in squares:
  i


for i in squares:
  squares[i]="white"

# enumerate can be used find the index and element in a list

for i,square in enumerate(squares):
  square
  i

```

while loops

```{python}

squares = ["orange","orange","orange","purple","orange"]
Newsquares=[]

i=0

while(squares[i]="orange"):

  Newsquares.append(squares[i])
  i=i+1

```

### Functions ###

Functions are functions.

example function:

```{python}

def add1(a):

  b=a+1

  return b

```

```{python}

def add1(a):
'''
this function takes an input, and adds '1' to it
'''
  b=a+1
  return b

help(add1)

```

```{python}

def mult(a,b):
  c=a*b
  return c

mult(3,8)

```

No returns...

```{python}

def MJ():
  print("Michael Jackson")

def NoWork():
  print(NoWork())

```

Multiple outputs

```{python}

def add2(a):
  b=a+1
  print(a, " plus 1 equals ", b)
  b

```

Loops in functions

```{python}

def printStuff(Stuff):
  for i,s in enumerate(Stuff):
    print("Album ", i, "'s rating is " , s)

```

Variadic parameters!

Variadic parameters accept a variable number of elements.

```{python}

def ArtistNames(*names):
  for name in names:
    print(name)

ArtistNames('leonardo','raphaelo')
# leonardo
# raphaelo
ArtistNames('leonardo','raphaelo','michaelangelo')
# leonardo
# raphaelo
# michaelangelo
ArtistNames('leonardo','raphaelo','michaelangelo','picasso')
# leonardo
# raphaelo
# michaelangelo
# picasso

```

Scope.

The scope of a variable, is the program space where that variable is accessible. A variable defined
outside of a function has a 'global scope', and is called a 'global variable'.

```{python}

def AddDC(x):
  x=x+"DC"
  print(x)
  return(x)

x="AC"
z=AddDC(x)

x
# 'AC'

print(AddDC(x))
# ACDC
# ACDC

```

Ah yeah, so we haven't given x a value yet, just declared it in the function. Then we assign it a value.
After this we can recruit it in the function?

Oh, I see now. 'x' has been globally defined as 'AC'.

In the function we've defined 'x' as 'ACDC', but this doesn't affect the global 'x' variable

- So you want to be *super* careful with how you define variables!

Python with first search withing the local scope for the variable value, and if it doesn't exist it will
check the global scope, and if it exists there, it will use that value.

You can also define a global variable in a function explicitly:

```{python}

def PinkFloyd():
  global ClaimedSales
  ClaimedSales="45 Million"
  return ClaimedSales

PinkFloyd()

print(ClaimedSales)

```







---

Useful functions:

```{python}

index()
len()
sorted()
add()
remove()

# sets logic
difference()
intersection()
union()
issubset()

```


