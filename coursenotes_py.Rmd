IMB/Edx Python course notes
===========================

Course Notes for the IMB python short course

```{python}
print( "hello world" )
```

Before I finish this course:

- Get python working (maybe it needs to be running inside a conda environment?)
- Get python scripts executing from the command line

Module 1
--------

Python Basics: 

### types ###

Pretty straightforwards stuff.

integers, floats, strings and booleans.

You can make conversions between types - python is pretty clever - and can even convert strings to integers (assuming the string is an integer), like

```{python}
int('1')
```

Will convert '1', into the integer 1.

Floats to integers drops the decimal, and thus loses information.

You can't convert lettersa and symbols to ints (but what about ACII codes?)

Booleans are either true (1) or false (0).

### Expressions ###

Just basic operations.

Variable assignment

```{python}
my_variable = 1
my_variable:1 # will apparently 'denote' the variable, which I'm wondering how this is different from assignment??
```

More straightforward stuff.

### Strings ###

Each element in a string is indexed by integers, either positive or negative.

String operations are fairly intuitive.

    3 * x == xxx

You cannot 'add' a string, but you can add *to* a string.

`3 + x` -- returns an error

But `'3' + x` -- adds the number '3' to the string

Backslashes `\`, as usual are escape characters.

Slicing can be done using indexes.

```{python}
a = 'the cat in the hat '
a[::2] # Take every second character starting from one -- THIS IS A STRIDE VALUE
# 'tecti h a '
a[0:5:2] # Take from 0 to 5, and return every second character - this is slicing
# 'tec'

"345678".find('3') # Ah I see -- 'return index value of string '3'
```

Module 2
--------

### Lists and tuples ###

Tuples are ordered lists, defined by parentheses.

Tuples can be made of strings, integers, floats, etc. and any combination of these.

A tuple is always of type: tuple.

Tuples can be sliced and concatenated.

```{python}
tuple1 = (1,2,3,4)
tuple2 = ('cat','dog',5.3)

tuple1 + tuple2 = tuple3

tuple3 =  (1,2,3,4,'cat','dog',5.3)

tuple3[2:5]

# (3,4,'cat')

tuple4 = (5,3.2,9,"letter opener",tuple3)

tuple4[4][5][1]

# o

```

So tuples can be nested. Which is even more powerful than it sounds.

From what I can gather, this is the equivalent of creating a list in R.

We can index down to the atomic level, even within strings.

Lists are like tuples, but mutable.

```{python}

list1 = ["Michael Jackson", 10.1, 1982]

list1.extend(["pop", 10])

list1 = ["Michael Jackson", 10.1, 1982, "pop", 10]

list1.append(["pop", 10])

list1 = ["Michael Jackson", 10.1, 1982, "pop", 10, ["pop", 10]]

list1[3] = "soda"

list1 = ["Michael Jackson", 10.1, 1982, "soda", 10, ["pop", 10]]

del(list1[1])

list1 = ["Michael Jackson", 1982, "soda", 10, ["pop", 10]]

"hard rock".split()

# ["hard", "rock"]
# so \s is the default delimiter then?

"a,b,c,d".split(',')

# ["a","b","c","d"]

# I guess that answers my question

```

OK, interesting.

Aliasing.

```{python}
A=B

```

aliases A with B. When you change anything in list A, it changes in B too.

Cloning:

```{python}
B=A[:]
# Again, it is simply referencing all elements of A
```

This will create an independent clone of A: B. A change in A will not induce a change in A, because they are now independent.

A fellow student shared [this](https://stackabuse.com/lists-vs-tuples-in-python/) really interesting tutorial on lists vs tuples.

It's becoming increasingly evident that I should find other ways to practise coding, other than the labs here.

Python is obviously more complex than SQL, and the labs are auite simple.

### Data Structures ###

Sets area  type of collection

you can input types.

Sets are unordered

Only have unique elements (no duplicates!).

use curly brackets

```{python}

set1={'dog','cat','aardvark','mouse'}

```

You can convert lists to sets

```{python}
list8 = set(list1)
```

Can add to a set

```{python}
set1.add('tiger')
```

If we add an element that exists, nothign will happen.

Can check to see if an item is in a set:

```{python}
'cat' in set1
```

We can perform lots of mathematical operations in sets.

```{python}

set1={'dog','cat','aardvark','mouse'}

set2={'dog','mouse','elephant','sloth'}

```

For intersection we use `&`

This will find the common elements of each set.

```{python}

# intersection
set1 & set2

# {'dog','mouse'}

# union

set1.union(set2)

# check to find if a set is a subset of another

set1.issubset(set2)

# False

```

### Dictionaries ###

Dictionaries are like lists.

Except their indexes are not integers, but custom values, often characters or strings.

The syntax is as follows:

```{python}
dictionary1 = {"key":"value","key2":[1,2,3],"key3":"5",("key6"):5}
```

Nice to think of a dictionary as a two column table

key | variable

We can add to a dictionary

```{python}
dictionary1['key4']='(5,4)'

del(dictionary1['key4'])

'key' in dictionary1
# true

'key1' in dictionary1
# false

dictionary1.keys()

dictionary1.values()

```

Module 3
--------

Zooming along again. When did I start this? Was it Sunday or Saturday?

- lots of familiar content
- should really do some real coding
  - eh, finish the course first

1. conditions and branching
2. loops and functions
3. objects and classes

### Conditions and branching ###

Mostly just stuff on operators and conditionals.

If statements. syntax?

```{python}

if (age>18): # The brackets are not necessary!

  print("you can enter")

print("move on")

```


```{python}

age = 17

if (age>18): # The brackets are not necessary!

  print("you can enter")

print("move on")

```

```{python}

if (age>18): # The brackets are not necessary!

  print("you can enter")

else:

  print("go see Meatloaf")

print("move on")

```

```{python}

if (age>18): # The brackets are not necessary!

  print("you can enter")

elif(age==18):

  print("go see Pink Floyd")

else:

  print("go see Meatloaf")

print("move on")

```

Logic Operators

AND and OR booleans.

Pretty straightforward stuff.

```{python}

albumYear = 1970

if albumYear < 1980 and albumYear > 1969:
  print("This album was made in the 70's")

```

### Loops ###

`range()` generates number sequences based on its input

```{python}
range(3)
# [0,1,2]
range(10,15)
# [10,11,12,13,14]
```

for loops, exactly as they are in essentially any other language, at least the basic concept is the same.

```{python}
squares = ["red","yellow","green","purple","blue"]
for i in range(0,5):
  squares[i]="white"

# We can iterate directly on the list

for i in squares:
  i


for i in squares:
  squares[i]="white"

# enumerate can be used find the index and element in a list

for i,square in enumerate(squares):
  square
  i

```

while loops

```{python}

squares = ["orange","orange","orange","purple","orange"]
Newsquares=[]

i=0

while(squares[i]="orange"):

  Newsquares.append(squares[i])
  i=i+1

```

### Functions ###

Functions are functions.

example function:

```{python}

def add1(a):

  b=a+1

  return b

```

```{python}

def add1(a):
'''
this function takes an input, and adds '1' to it
'''
  b=a+1
  return b

help(add1)

```

```{python}

def mult(a,b):
  c=a*b
  return c

mult(3,8)

```

No returns...

```{python}

def MJ():
  print("Michael Jackson")

def NoWork():
  print(NoWork())

```

Multiple outputs

```{python}

def add2(a):
  b=a+1
  print(a, " plus 1 equals ", b)
  b

```

Loops in functions

```{python}

def printStuff(Stuff):
  for i,s in enumerate(Stuff):
    print("Album ", i, "'s rating is " , s)

```

Variadic parameters!

Variadic parameters accept a variable number of elements.

```{python}

def ArtistNames(*names):
  for name in names:
    print(name)

ArtistNames('leonardo','raphaelo')
# leonardo
# raphaelo
ArtistNames('leonardo','raphaelo','michaelangelo')
# leonardo
# raphaelo
# michaelangelo
ArtistNames('leonardo','raphaelo','michaelangelo','picasso')
# leonardo
# raphaelo
# michaelangelo
# picasso

```

Scope.

The scope of a variable, is the program space where that variable is accessible. A variable defined
outside of a function has a 'global scope', and is called a 'global variable'.

```{python}

def AddDC(x):
  x=x+"DC"
  print(x)
  return(x)

x="AC"
z=AddDC(x)

x
# 'AC'

print(AddDC(x))
# ACDC
# ACDC

```

Ah yeah, so we haven't given x a value yet, just declared it in the function. Then we assign it a value.
After this we can recruit it in the function?

Oh, I see now. 'x' has been globally defined as 'AC'.

In the function we've defined 'x' as 'ACDC', but this doesn't affect the global 'x' variable

- So you want to be *super* careful with how you define variables!

Python with first search withing the local scope for the variable value, and if it doesn't exist it will
check the global scope, and if it exists there, it will use that value.

You can also define a global variable in a function explicitly:

```{python}

def PinkFloyd():
  global ClaimedSales
  ClaimedSales="45 Million"
  return ClaimedSales

PinkFloyd()

print(ClaimedSales)

# What's a comment in jelleybeans - not bad, a bit more contrast than apprentice

```

### Objects and Classes ###

All data types are objects. All objects have:

- a type
- an internal data representation
- methods

an object is an instance of a particular type.

When we invoke an integer, we an invoking an 'int' object, which is of type 'int' (duh).

Methods are invoked by appending a period at the end of the object.

So, depending on the attributes of the object, some methods will work on it, some will not?

So a class is *kind of* like a function. So what's the difference exactly?

Class is a collection of objects, I think it's sinking in now. 

`5` is an element, or object, of `<class int>`
`dog` is an element, or object, of `<class str>`

So you can define your own class - so far as I can tell this means, you can create a particular set of characteristics, to which a set of objects can be described by, or defined by.

The followings are class members.

1. Class Attributes
2. Constructor
3. Instance Attributes
4. Properties
5. Class Methods

```{python}

class ThisisANewClass:
  <statement1>
  <statement2>
  ...
  <statementn>

```

So the fucken video starts off talking about integers being 'types', and I can't see anywhere, where it clarifies that 'type' is effectively the same as 'class'. Are they different?

So `sort()` is a method, but `type()` is a function? - just came to this realization doing some stuff in IDLE.

And so, according to some stack QnA, 'types' are basically builtins, and classes are user defined, but in this day and age there are no substantive differences. I suppose you can still think of types as builtin, and written in C, whearas classes are mostly user defined. But they now work the same way, and there is virtually no practical difference?

So now we're going to create our own classes 'circle' and 'rectangle'.

So, to make a circle, we need a radius. We can also add a colour, just to make things fancy.

so our attributes are 'radius' and 'color' (keeping it American).

Rectangle needs 'height' and 'width' and 'color'

```{python}

class Circle(object):

  def __init__(self,radius,color):
    self.radius = radius;
    self.color = color;

# __init__ is a constructor - this tells python you are making a new class (so it is sort of required to instantiate a class? Am I using 'instantiate' correctly here?

class Rectangle(object):

  def __init__(self,height,width,color):
    self.height = height;
    self.width = width;
    self.color = color;

```

```{python}

# Create a class
Redcircle = Circle(10,'red')
Redcircle
# <__main__.Circle object at 0x7fc1ec7a0550
# call the attributes
Redcircle.radius
# 10
Redcircle.color
# 'red'
C2 = Circle(5, 'blue')
C2.color
# 'blue'
# change the attribute directly
C2.color = 'green'
C2.color
# 'green'

```

Methods are functions which can change the attributes of the object.

```{python}

class Circle(object):

  def __init__(self,radius,color):
    self.radius = radius;
    self.color = color;

  def add_radius(self,r):
    self.radius=self.radius+r;

```

Phew. That video was intense.

> Functions *do* specific things, classes *are* specific things. 

From [this Stack Question](https://stackoverflow.com/questions/18202818/classes-vs-functions)

```{python}

class Circle(object):
  def __init__ (self, radius=3, color='blue'):
    self.radius = radius
    self.color = color
  def add_radius(self, r):
    self.radius = self.radius+r
    return(self.radius)
  def DrawCircle(self):
    plt.gca().add_patch(plt.Circle((0,0), radius = self.radius, fc=self.color))
    plt.axis('scaled')
    plt.show()

```

[//]: # ( This is taking too long - I need to work through the labs faster, and take note of what is difficult, and work on improving that later with practise )
[//]: # ( Man some colorschemes are *weird!* )

[python exceptions](https://docs.python.org/3/library/exceptions.html) - looks useful!

```{python}
a = 1

try:
    b = int(input("Please enter a number to divide a"))
    a = a/b
    print("Success a=",a)
except ZeroDivisionError:
    print("The number you provided cant divide 1 because it is 0")
except ValueError:
    print("You did not provide a number")
except:
    print("Something went wrong")

```

Module 4
--------

Working with Data in python. OK, so we're getting onto the Data Science stuff now.

I think those last 2 modules went pretty quick and dirty through the basics. I wonder if a more extensive course will go a little slower through, and give you more time to build your intuition around a topic before hitting you with a heavy lab exercise?

### Reading files with open ###

Open function.

The second argument is the 'mode'

```{python}

file1 = open("path/to/file.txt","w")

# w = writing
# r = reading
# a = appending

```

Interesting.

    file1.name

Returns a string containing the file name "path/to/gile.txt"

    file1.mode

Indicates the mode 'w' for example.

'with' statement.

You can open a file, for a specific purpose, and then it closes when it is done:

```{python}

with open("path/to/file.txt","w") as file1:

  file_stuff = file1.read()
  print(file_stuff)

print(file1.closed)
print(file_stuff)

```

So, python can 'open' a file in read, write and append mode, but it can also store the contents of the file into an object. That's actually pretty cool.

I wonder if the use of loops is unintuitive to me, because I'm used to R parallelizing over everything.

I am starting to see how in python, everything is looped.

So basically, you can access and read files, and do lots of stuff to them.

I *really* need to do some real stuff with python, get used to doing this stuff.

Closing files at the end is very important!

> Using the with statement is better practice, it automatically closes the file even if the code encounters an exception. The code will run everything in the indent block then close the file object.

Yep, so can open the file, save the contents into an object, and then close it, and still have the contents in an object (duh).

But it means you probably like to read in a file, then perform changes to the saved object in python, then write the object to the old, or a new file.



---

Useful functions:

```{python}

index()
len()
sorted()
add()
remove()

# sets logic
difference()
intersection()
union()
issubset()

```


